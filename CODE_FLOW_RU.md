# Описание Работы Кода ESP32 - Датчик CO2

## Обзор

ESP32 просыпается каждые 10 секунд, считывает данные с датчиков, сохраняет их на SD-карту и отправляет в AWS при наличии интернета.

---

## Функция: `v2()` - Основной Цикл Сбора Данных

### 1. Подключение к WiFi

```cpp
void v2(){
  connectToWiFi();  // Попытка подключения к WiFi (устанавливает флаг 'connected')
```

**Назначение:** Попытка подключения к WiFi. При успехе `connected = true`.

---

### 2. Чтение Датчиков

```cpp
  SData data;           // Структура для хранения показаний датчиков
  uint64_t now;         // Временная метка в миллисекундах
  data.ppm = myMHZ19.getCO2();        // Чтение CO2 с MH-Z19C
  data.t = myMHZ19.getTemperature();  // Чтение температуры с MH-Z19C
  data.h = dht.readHumidity();        // Чтение влажности с DHT-22
  unsigned long startMillis = millis(); // Отметка времени старта
```

**Назначение:** Считывание всех показаний датчиков в структуру `data`.

**Датчики:**
- **MH-Z19C:** CO2 (ppm) и температура (°C)
- **DHT-22:** Влажность (%)

---

### 3. Управление Временем

#### 3.1. Режим Онлайн (WiFi подключен)

```cpp
  if (connected) {
    configTime(5 * 3600, 0, "pool.ntp.org");  // Установка часового пояса UTC+5, синхронизация с NTP
    time_t seconds;                            // Unix timestamp в секундах
    time(&seconds);                            // Получение текущего времени с NTP
    now = (uint64_t)seconds * 1000;            // Конвертация в миллисекунды
  }
```

**Когда Онлайн:**
- `configTime(5 * 3600, 0, "pool.ntp.org")` - Настройка смещения часового пояса (+5 часов) и синхронизация с NTP сервером
- `time(&seconds)` - Получение текущего Unix timestamp в секундах (например, 1730491200)
- `now = seconds * 1000` - Конвертация в миллисекунды (например, 1730491200000)

**Результат:** Точное время с интернета.

---

#### 3.2. Режим Оффлайн (WiFi не подключен)

```cpp
  else{
    prefs.begin("time", true);                    // Открытие preferences (только чтение)
    uint64_t lastTime = prefs.getULong64("savedtime", 0);  // Получение последней сохраненной метки
    prefs.end();
    
    if (lastTime == 0) {
      now = millis();  // Никогда не синхронизировалось: используем миллисекунды с момента загрузки
    } else {
      now = lastTime + 10000;  // Ранее синхронизировалось: добавляем 10 секунд
    }
  }
```

**Когда Оффлайн:**
- Извлечение последней сохраненной временной метки из flash-памяти
- **Если `lastTime == 0`:** Устройство никогда не синхронизировалось с NTP → используем `millis()` (относительное время)
- **Если `lastTime > 0`:** Устройство ранее синхронизировалось → добавляем 10000мс (10 секунд интервала сна)

**Примеры:**

| Пробуждение | lastTime | Расчет | now | Описание |
|-------------|----------|--------|-----|----------|
| 1-е | 0 | millis() | 500 | Никогда не было онлайн |
| 2-е | 500 | 500 + 10000 | 10500 | Относительное время |
| 3-е | 10500 | 10500 + 10000 | 20500 | Продолжение счета |
| ... | ... | ... | ... | ... |
| После синхронизации | 1730491200000 | NTP | 1730491200000 | Получено точное время |
| Следующее (оффлайн) | 1730491200000 | 1730491200000 + 10000 | 1730491210000 | Продолжение от точного |

---

```cpp
  data.time=now;  // Присвоение временной метки структуре данных
```

**Назначение:** Сохранение рассчитанной временной метки вместе с показаниями датчиков.

---

### 4. Сохранение на SD-карту

```cpp
  File fileW = SD_MMC.open("/array.bin", FILE_APPEND);  // Открытие файла в режиме добавления
  fileW.write((uint8_t*)&data, sizeof(data));           // Запись бинарной структуры
  fileW.close();
```

**Назначение:** Добавление данных датчиков + временной метки в бинарный файл на SD-карте.

**Формат данных:**
```cpp
struct SData {
  float t;      // Температура (°C)
  float h;      // Влажность (%)
  float ppm;    // CO2 (ppm)
  uint64_t time; // Временная метка (миллисекунды)
};
```

**Размер записи:** 20 байт (4+4+4+8)

---

### 5. Отправка в AWS (если онлайн)

```cpp
  if (connected) {
    File fileR = SD_MMC.open("/array.bin", FILE_READ);   // Открытие сохраненных данных
    File tempFile = SD_MMC.open("/temp.bin", FILE_WRITE); // Временный файл для неотправленных данных
    bool allSent = true;  // Отслеживание успешности всех загрузок
```

**Назначение:** Чтение всех сохраненных данных и попытка загрузки.

---

#### 5.1. Цикл Отправки

```cpp
    while (fileR.read((uint8_t*)&data, sizeof(data)) == sizeof(data)) {
      if (allSent) {  // Пытаемся отправить только если не было предыдущих ошибок
        HTTPClient https;
        https.begin("https://co2.arsen.ganibek.com/ingest");
        https.addHeader("Content-Type", "application/x-www-form-urlencoded");
        String payload = "&t=" + String(data.t) + "&h=" + String(data.h) 
                       + "&ppm=" + String(data.ppm) + "&time=" + String(data.time);
        int httpCode = https.POST(payload);  // Отправка в AWS
```

**Назначение:**
- Чтение каждой записи из файла
- Формирование URL-encoded payload
- POST запрос к AWS API Gateway

**Пример payload:**
```
&t=23.5&h=65.2&ppm=450&time=1730491200000
```

---

#### 5.2. Обработка Результата

```cpp
        if(httpCode != 200){
          allSent = false;                          // Отметка ошибки
          tempFile.write((uint8_t*)&data, sizeof(data));  // Сохранение этой записи
        }
      } else {
        tempFile.write((uint8_t*)&data, sizeof(data));  // Сохранение оставшихся записей
      }
    }
```

**Логика:**
- **Успех (200):** Запись удаляется (не записывается во временный файл)
- **Ошибка (≠200):** Запись сохраняется во временный файл, прекращение попыток отправки
- **После первой ошибки:** Все оставшиеся записи сохраняются во временный файл

**Преимущество:** Не отправляем одни и те же данные повторно, экономим батарею и трафик.

---

#### 5.3. Замена Файла

```cpp
    fileR.close();
    tempFile.close();
    SD_MMC.remove("/array.bin");           // Удаление оригинального файла
    SD_MMC.rename("/temp.bin", "/array.bin");  // Переименование временного в оригинальный
  }
```

**Назначение:** Замена оригинального файла только неотправленными данными. Успешно отправленные записи удалены.

**Результат:** Файл уменьшается по мере успешной отправки данных.

---

### 6. Сохранение Временной Метки для Следующего Пробуждения

```cpp
  prefs.begin("time", false);           // Открытие preferences (режим записи)
  prefs.putULong64("savedtime", now);   // Сохранение текущей временной метки
  prefs.end();
```

**Назначение:** Сохранение временной метки во flash-памяти, чтобы следующее пробуждение могло рассчитать время.

**Важно:** Сохраняется текущая метка `now`, а не `now + 10000`. Добавление 10 секунд происходит при следующем пробуждении.

---

### 7. Глубокий Сон

```cpp
  delay(500);
  sleep();  // Вход в глубокий сон на 10 секунд
}
```

**Функция `sleep()`:**
```cpp
void sleep(){
  WiFi.disconnect(true);
  WiFi.mode(WIFI_OFF);
  btStop();
  esp_sleep_enable_ext0_wakeup((gpio_num_t)pini, 1);  // Пробуждение по кнопке
  esp_sleep_enable_timer_wakeup(10 * 1000000ULL);     // Пробуждение через 10 секунд
  esp_deep_sleep_start();
}
```

**Назначение:** 
- Отключение WiFi и Bluetooth для экономии энергии
- Настройка пробуждения по таймеру (10 секунд) или кнопке
- Вход в глубокий сон

**Потребление:** ~10 мкА в режиме глубокого сна (vs ~240 мА в активном режиме)

---

## Общий Поток Работы

```
┌─────────────────────────────────────────────────────────────┐
│ 1. Пробуждение (каждые 10 секунд)                          │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. Попытка подключения к WiFi                               │
│    → connected = true/false                                 │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. Чтение датчиков                                          │
│    → CO2, температура, влажность                            │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. Получение временной метки                                │
│    ┌─────────────────┬──────────────────────────────────┐   │
│    │ Онлайн          │ Оффлайн                          │   │
│    ├─────────────────┼──────────────────────────────────┤   │
│    │ NTP время       │ lastTime == 0: millis()          │   │
│    │                 │ lastTime > 0: lastTime + 10000   │   │
│    └─────────────────┴──────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. Сохранение на SD-карту                                   │
│    → Добавление записи в /array.bin                         │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. Если онлайн: Отправка в AWS                              │
│    → Чтение всех записей из файла                           │
│    → POST запросы к API Gateway                             │
│    → Удаление успешно отправленных записей                  │
│    → Сохранение неотправленных записей                      │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 7. Сохранение временной метки                               │
│    → prefs.putULong64("savedtime", now)                     │
└─────────────────────────────────────────────────────────────┘
                            ↓
┌─────────────────────────────────────────────────────────────┐
│ 8. Глубокий сон (10 секунд)                                 │
│    → Потребление: ~10 мкА                                   │
└─────────────────────────────────────────────────────────────┘
                            ↓
                    (Повтор с шага 1)
```

---

## Ключевые Особенности

### ✅ Надежность
- Данные никогда не теряются (сохраняются на SD-карту)
- Повторная отправка только неотправленных данных
- Работа без интернета с относительными временными метками

### ✅ Энергоэффективность
- Глубокий сон между измерениями (~10 мкА)
- Отключение WiFi/Bluetooth в режиме сна
- Прекращение отправки после первой ошибки (экономия батареи)

### ✅ Точность Времени
- Онлайн: Синхронизация с NTP (точность ±1 секунда)
- Оффлайн: Инкрементальное время (точность ±10 секунд на цикл)
- Автоматическая синхронизация при восстановлении связи

### ✅ Эффективность Передачи
- Отправка только новых данных
- Пакетная обработка всех накопленных записей
- Удаление успешно отправленных данных

---

## Структура Данных

### Формат Записи на SD-карте

```cpp
struct SData {
  float t;      // 4 байта - Температура (°C)
  float h;      // 4 байта - Влажность (%)
  float ppm;    // 4 байта - CO2 (ppm)
  uint64_t time; // 8 байт - Временная метка (мс)
};
// Всего: 20 байт на запись
```

### Формат Отправки в AWS

```
POST https://co2.arsen.ganibek.com/ingest
Content-Type: application/x-www-form-urlencoded

&t=23.5&h=65.2&ppm=450&time=1730491200000
```

### Хранение в DynamoDB

```json
{
  "deviceId": "esp32-001",
  "timestamp": 1730491200000,
  "temperature": 23.5,
  "humidity": 65.2,
  "co2": 450,
  "ttl": 1762027200
}
```

---

## Расчет Потребления Энергии

**Активный режим (WiFi включен):** ~240 мА × 2 секунды = 480 мА·с  
**Режим сна:** ~0.01 мА × 8 секунд = 0.08 мА·с  
**Средний ток:** (480 + 0.08) / 10 = ~48 мА

**Батарея 9V 500mAh:**  
Время работы: 500 мАч / 48 мА ≈ **10 часов**

**Примечание:** Для длительной работы рекомендуется использовать литий-ионный аккумулятор 18650 (3.7V, 3000mAh) с повышающим преобразователем.

---

## Возможные Улучшения

1. **Батарея:** Использовать Li-Ion 18650 вместо 9V
2. **Интервал:** Увеличить до 60 секунд для экономии энергии
3. **Сжатие:** Использовать бинарный протокол вместо URL-encoded
4. **Буферизация:** Отправлять пакетами по 10 записей
5. **Индикация:** Добавить LED для статуса (WiFi, отправка, ошибка)
